!
! Copyright (C) 2001-2021 Quantum ESPRESSO group
! This file is distributed under the terms of the
! GNU General Public License. See the file `License'
! in the root directory of the present distribution,
! or http://www.gnu.org/copyleft/gpl.txt .
!

! XML routines non relying on qexsd. For a small code such as
! GIPAW, qexsd is an overkill. Here I use the FoX library directly
! to input and output XML files

! commodity macros
#define CHECK_IONODE if (.not. ionode) return

! XML output
#define NE(x) call XML_NewElement(xmlf, #x)
#define ADDS(x) call XML_AddCharacters(xmlf, trim((x)))
#define ADDV(x) call XML_AddCharacters(xmlf, (x))
#define EE(x) call XML_EndElement(xmlf, #x)
#define OUTS(x) call XML_NewElement(xmlf, #x); call XML_AddCharacters(xmlf, trim((x))); call XML_EndElement(xmlf, #x);
#define OUTV(x) call XML_NewElement(xmlf, #x); call XML_AddCharacters(xmlf, (x)); call XML_EndElement(xmlf, #x);
#define ATTR(x,y) call XML_AddAttribute(xmlf, #x, (y))

!-----------------------------------------------------------------------
MODULE xml_routines
!-----------------------------------------------------------------------  
  ! ... This module contains the variables routines to I/O the XML files
  USE kinds,                       ONLY : dp
  USE io_global,                   ONLY : ionode
  USE fox_wxml                     ! to output XML
  USE fox_dom                      ! to parse XML file

  IMPLICIT NONE
  SAVE
  
  type(xmlf_t) :: xmlf             ! xml file handle

  character(5),  parameter :: fmt_name = "QEXSD"
  character(8),  parameter :: fmt_version = "21.07.16"

  PUBLIC :: open_xml_output, close_xml_output
  PUBLIC :: xml_output_generalinfo, xml_output_parallelinfo
  PUBLIC :: xml_output_namelist, xml_output_results
  PUBLIC :: xml_output_status
  PUBLIC :: xml_output_timinginfo
  PUBLIC :: xml_output_closed

  CONTAINS

  !-----------------------------------------------------------------------
  SUBROUTINE open_xml_output(filename)
  !-----------------------------------------------------------------------
    implicit none
    character(len=*), intent(in) :: filename
    integer :: ierr

    CHECK_IONODE
    call XML_OpenFile(filename, xmlf, replace=.true., pretty_print=.true., namespace=.true., iostat=ierr)
    !if ierr

    ! write namespace
    call XML_DeclareNamespace(xmlf, prefix="xsi", nsURI="http://www.w3.org/2001/XMLSchema-instance")
    call XML_DeclareNamespace(xmlf, prefix="qes", nsURI="http://www.quantum-espresso.org/ns/qes/qes-1.0")
    call XML_NewElement(xmlf, name="qes:espresso")
    call XML_AddAttribute(xmlf, name="xsi:schemaLocation", &
                          value="http://www.quantum-espresso.org/ns/qes/qes-1.0 "//&
                                "http://www.quantum-espresso.org/ns/qes/qes_210716.xsd")   ! cambiare questo!!!
  END SUBROUTINE open_xml_output


  !-----------------------------------------------------------------------
  SUBROUTINE close_xml_output
  !-----------------------------------------------------------------------
    implicit none
   
    CHECK_IONODE
    call XML_Close(xmlf, empty=.false.)

  END SUBROUTINE close_xml_output


  !-----------------------------------------------------------------------
  SUBROUTINE xml_output_generalinfo
  !-----------------------------------------------------------------------
    USE gipaw_version
    implicit none
    character(9) :: cdate, ctime
    character(60) :: timestamp

    call date_and_tim(cdate, ctime)
    timestamp = 'This run was terminated on:  ' // ctime // ' ' // cdate(1:2) // ' '//cdate(3:5) // ' '// cdate (6:9)

    CHECK_IONODE
    NE(general_info)
      NE(xml_format)
        ATTR(name, fmt_name)
        ATTR(version, fmt_version)
        ADDV(fmt_name//'_'//fmt_version)
      EE(xml_format)
      NE(creator)
        ATTR(name, 'GIPAW')
        ATTR(version, gipaw_git_revision)
        ADDV('XML file generated by GIPAW')
      EE(creator)
      NE(created)
        ATTR(date, cdate)
        ATTR(time, ctime)
        ADDS(timestamp)
      EE(created)
    EE(general_info)

  END SUBROUTINE xml_output_generalinfo


  !-----------------------------------------------------------------------
  SUBROUTINE xml_output_parallelinfo
  !-----------------------------------------------------------------------
    USE mp_world,         ONLY : nproc
    USE mp_pools,         ONLY : npool
    USE mp_bands,         ONLY : ntask_groups, nproc_bgrp, nbgrp
    implicit none
    integer :: nthreads=1
#if defined(__OMP) 
    integer, external :: omp_get_max
    nthreads = omp_get_max()
#endif      

    CHECK_IONODE
    NE(parallel_info)
      OUTV(nproc)
      OUTV(nthreads)
      OUTV(ntask_groups)
      OUTV(nbgrp)
      OUTV(npool)
      OUTV(nproc_bgrp)
    EE(parallel_info)

  END SUBROUTINE xml_output_parallelinfo


  !-----------------------------------------------------------------------
  SUBROUTINE xml_output_namelist
  !-----------------------------------------------------------------------
    USE io_files,        ONLY : prefix, tmp_dir
    USE uspp_data,       ONLY : spline_ps
    USE gipaw_module     ! to access internal variables
    implicit none

    CHECK_IONODE
    NE(input)
      OUTS(job)
      OUTS(prefix)
      OUTS(tmp_dir)
      OUTV(conv_threshold)
      OUTS(restart_mode)
      OUTV(q_gipaw)
      OUTS(verbosity)
      OUTS(filcurr)
      OUTS(filfield)
      OUTS(filnics)
      OUTV(pawproj)
      OUTV(use_nmr_macroscopic_shape)
      OUTV(nmr_macroscopic_shape)
      OUTV(spline_ps)
      OUTS(diagonalization)
      OUTV(q_efg)
      OUTV(max_seconds)
      OUTV(r_rand)
      OUTS(hfi_output_unit)
      OUTV(hfi_nuclear_g_factor)
      OUTV(core_relax_method)
      OUTV(hfi_via_reconstruction_only)
    EE(input)
  END SUBROUTINE xml_output_namelist


  !-----------------------------------------------------------------------
  SUBROUTINE xml_output_susceptibility
  !-----------------------------------------------------------------------
    USE gipaw_results
    implicit none

    CHECK_IONODE
    NE(suceptibility_low)
      ATTR(units, '1e-6 cm^3/mol')
      ADDV(res_suscept1)
    EE(suceptibility_low)
    NE(suceptibility_high)
      ATTR(units, '1e-6 cm^3/mol')
      ADDV(res_suscept2)
    EE(suceptibility_high)

  END SUBROUTINE xml_output_susceptibility


  !-----------------------------------------------------------------------
  SUBROUTINE xml_atom_attributes(na)
  !-----------------------------------------------------------------------
    USE gipaw_results
    USE ions_base, ONLY: tau, atm, ityp
    implicit none
    integer, intent(in) :: na

    ATTR(atom, trim(atm(ityp(na))))
    ATTR(tau, tau(:,na))

  END SUBROUTINE xml_atom_attributes


  !-----------------------------------------------------------------------
  SUBROUTINE xml_output_results
  !-----------------------------------------------------------------------
    USE gipaw_module     ! to access internal variables
    USE gipaw_results
    USE ions_base, ONLY: nat
    implicit none
    integer :: na

    CHECK_IONODE
    NE(output)

    if (job == 'nmr') then
      call xml_output_susceptibility
      NE(shielding_tensors)
      do na = 1, nat
        NE(sigma)
          ATTR(units, 'ppm')
          call xml_atom_attributes(na)
          ADDV(res_nmr_sigma(:,:,na))
        EE(sigma)
      enddo
      EE(shielding_tensors)
    endif

    if (job == 'g_tensor') then
      call xml_output_susceptibility
      NE(delta_g)
        ATTR(units, 'ppm')
        OUTV(res_epr_deltag)
      EE(delta_g)
      NE(delta_g_paratec)
        ATTR(units, 'ppm')
        OUTV(res_epr_deltag_paratec)
      EE(delta_g_paratec)
    endif

    if (job == 'efg') then
      NE(electric_field_gradients)
        do na = 1, nat
          NE(efg)
            ATTR(units, 'MHz')
            call xml_atom_attributes(na)
            ADDV(res_efg(:,:,na))
          EE(efg)
        enddo
        EE(electric_field_gradients)
    endif

    if (job == 'hyperfine') then
      NE(hyperfine_couplings)
      do na = 1, nat
        NE(hfi_dipolar)
          ATTR(units, trim(hfi_output_unit))
          call xml_atom_attributes(na)
          ADDV(res_hfi_dip(:,:,na))
        EE(hfi_dipolar)
      enddo
      do na = 1, nat
        NE(hfi_fermi_contact)
          ATTR(units, trim(hfi_output_unit))
          call xml_atom_attributes(na)
          ADDV(res_hfi_fc(na))
        EE(hfi_fermi_contact)
      enddo
      EE(hyperfine_couplings)
    endif

    EE(output)

  END SUBROUTINE xml_output_results


  !-----------------------------------------------------------------------
  SUBROUTINE xml_output_status
  !-----------------------------------------------------------------------
    implicit none
    integer :: status = 0

    CHECK_IONODE
    OUTV(status)

  END SUBROUTINE xml_output_status


  !-----------------------------------------------------------------------
  SUBROUTINE xml_output_closed
  !-----------------------------------------------------------------------
    implicit none
    character(9) :: cdate, ctime

    CHECK_IONODE
    call date_and_tim(cdate, ctime)
    NE(closed)
       ATTR(date, cdate)
       ATTR(time, ctime)
    EE(closed)

  END SUBROUTINE xml_output_closed


  !-----------------------------------------------------------------------
  SUBROUTINE xml_output_timinginfo
  !-----------------------------------------------------------------------
    USE gipaw_module
    implicit none
    real(dp), external :: get_clock
    real(dp) :: wall

    CHECK_IONODE
    NE(timing_info)
      NE(total)
        ATTR(label, 'GIPAW')
        wall = get_clock('GIPAW')
        OUTV(wall)
      EE(total)

    EE(timing_info)

  END SUBROUTINE xml_output_timinginfo


END MODULE xml_routines

